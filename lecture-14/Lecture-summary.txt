Hooks - ჯავასკრიპტის ფუნქციაა
    - გამოიყენება ფუნქციურ კომპონენტებში და სხვა ჰუკებში
    - მისი სახელი უნდა იწყებოდეს use-ით
    - hook-ში შეიძლება გამოვიყენოთ სხვა hook-ით
    - hook გამოიყენება ფუნქციური კომპონენტის ტოპ ლეველზე (ცილკებში, if...else-ში არგამოიყენება)

useState - ფუნქციურ კომპონენტში გამოიყენება state-ის შესაქმნელად. იგი აბრუნებს ორ ელემენტიან მასივს სადაც პირველი ელემენტი არის state-ის მიმდინარე მნიშვნელობა, ხოლო მეორე არის ფუნქცია ამ state-ის გასაახლებლად. useState-ს აქვს batching-ის თვისება რაც ნიშნავს state-ში ყველა ცვლილების გაერთიანებას და მხოლოდ ერთი რენდერით ასახვას.

useEffect- ეს არის კლასური კომპონენტების რამდენიმე lifecycle მეთოდის ერთობლიობა და ფუნქციურ კომპონენტებში გამოიყენება რენდერის შემდეგ ან მისი მიმდინარეობის დროს ოპერაციების გასაშვებად. useEffect გამოიყენება ასინქრონულ ოპერაციებთან სამუშაოდაც. იგი ცვლის componentDidMount, componentDidUpdate, componentWillUnmount მეთოდებს. 
useEffect აქვს ორი პარამეტრი :
    1. ფუნქცია(ქოლბექი) 
    2. Dependency Array - რომელიც იღებს სამ მნიშვნელობას: 
        -[] - ცარიელი მასივი. ეს ნიშნავს რომ შესრულდება componentDidMount-ის ექვივალენტი lifecycle მეთოდი, ანუ კომპონენტი დარენდერდება მხოლოდ ერთხელ როდესაც იგი ჩაიტვირთება.

        -მასივის მითითების გარეშე. ეს ნიშნავს რომ ამუშავდება componentDidUpdate და რენდერი გაეშვება ყოველ ჯერზე როდესაც prop ან state შეიცვლება.

         -[state/prop] - მასივში მითითებული state/prop ღირებულება. ეს ნშნავს რომ ხდება ზედა ორი ქმედების კომბინაცია, ჩაიტვირტება პირველ ჯერზეც და გეშვება ყოველ აფდეითზე.

თუკი useEffect ვეუბნებით რომ დააბრუნოს რაიმე ფუნქცია, იგი ასრულებს componentWillUnmount lifecycle მეთოდს და ჩახსნის კომპონენტთან დაკავშირეულ ლისენერებს. აქვე გვაქვს შესაძლებლობა, ქლინაფის შესრულებამდე დავინახოთ რა იყო წინა value. 

useRef - მცირედით გაქვს useState-ს, ორივე ობიექია და მათში შეგვიძლია შევინახოთ ნებისმიერი რამ, მაგრამ useRef გვაძლევს ობიექტს რომელიც ხილვადია კომპონენტის სასიცოცხლო ციკლის მანძილზე, მასში ხშირად ინახავენ JSX ელემენტებს როდესაც უნდათ კონკრეტულ ელემენტს მიწვდნენ და ამოიღონ (იგივე პრინციპით როგორც getEelementById, ასეთი სახით მონიშვნა არ არის მიზანშეწონილი React-ში). 
useRef არ იცვლება კომპონენტის გადარენდერების დროს და არც თავად იწვევს მის გადარენდერებას.

useMemo - გვიბრუნებს დამახსოვრებულ მნიშვნელობას (Memorized Value), რომლის ცვლილება ავტომატურად არ მოხდება.

useCallback - გვიბრუნებს დამახსოვრებულ ფუნქციას (Memorized Function), რომლის რეკონსტრუქტირებასაც რეაქტი არ მოახდენს ავტომატურად, რენდერის დროს. მეორე პარამეტრად გადაეცემა Dependency Array.

React.memo - წარმოადგენს კომპონენტის დამახსოვრების მეთოდს (Pure Component-ის ანალოგი). მხოლოდ მაშინ ხდება კომპონენტის გადარენდერება როდესაც მისი props იცვლება.